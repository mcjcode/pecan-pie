;;
;; At long last, we prove that 0 and 1 are not equal!
;;

;;
;; the key, to me, is observing that eliminators
;; such as which-Nat are able to tell Nats apart.
;;

;; Based on this observation, we define an ind-Nat motive
;;
;;   0          -->  Trivial
;;   Otherwise  -->  Absurd
;;
(claim WhatIfZero=
  (-> Nat U))
(define WhatIfZero=
  (lambda (n)
    (which-Nat n
      Trivial
      (lambda (_)
        Absurd))))

;; If you pass in 0, you get back a
;;
;; (-> (= Nat 0 0) Trivial)
;;
;; which tells you nothing
;;
;; but if you pass in anything other n, you
;; get back a
;;
;; (-> (= Nat 0 n) Absurd)
;;
;; proving that 0 and n are not equal.
;;
(claim zero?
  (Pi ([n Nat])
    (-> (= Nat 0 n)
        (WhatIfZero= n))))
(define zero?
  (lambda (n)
    (lambda (zero=n)
      (replace zero=n
        WhatIfZero= ;; the motive
        sole))))    ;; the base (the only value of type (WhatIfZero= 0))

;;
;; Try it out.
;;
(claim zero-does-not-equal-one
  (-> (= Nat 0 1) Absurd))
(define zero-does-not-equal-one
  (zero? 1))

;; zero-does-not-equal-one
;;
;; (the (→ (= Nat 0 1)
;;        Absurd)
;;   (lambda (zero=n)
;;     (the Absurd
;;       (replace zero=n
;;         (λ (n)
;;           (which-Nat n
;;              (the U Trivial)
;;              (λ (_)
;;                Absurd)))
;;         sole))))
