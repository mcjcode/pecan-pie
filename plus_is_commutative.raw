@(include "nats.raw")  ;; get the definition of +

;; Now let's prove that + is commutative
;; i.e. that (+ n m) *equals* (+ m n)
;;
;; This will be an induction on n, but
;; at each n-step we will have to induct
;; on m.
(claim mot-plus-is-commutative-part1
 (Pi ([m Nat]) U))
(define mot-plus-is-commutative-part1  
 (lambda (m) (= Nat (+ m 0) (+ 0 m))))
  
(claim base-plus-is-commutative-part1
 (= Nat (+ 0 0) (+ 0 0)))
(define base-plus-is-commutative-part1
 (same 0))

(claim step-plus-is-commutative-part1
 (Pi ([m-1 Nat])
  (-> (= Nat (+       m-1  0) (+ 0       m-1))
      (= Nat (+ (add1 m-1) 0) (+ 0 (add1 m-1))))))
(define step-plus-is-commutative-part1
 (lambda (_) ;; (m-1), but we don't need it
  (lambda (casem-1)
   (cong casem-1 (the (-> Nat Nat) (lambda (k) (add1 k)))))))

(claim plus-is-commutative-part1
 (Pi ([m Nat]) ;; note that square brackets here work too.
  (= Nat (+ m 0) (+ 0 m))))
(define plus-is-commutative-part1
 (lambda (m)
  (ind-Nat m
           mot-plus-is-commutative-part1
           base-plus-is-commutative-part1
           step-plus-is-commutative-part1)))

(claim mot-plus-is-commutative
 (Pi ([n Nat])
     U))
(define mot-plus-is-commutative
  (lambda (n)
    (Pi ([m Nat])
      (= Nat (+ m n) (+ n m)))))

(claim base-plus-is-commutative
 (Pi ([m Nat])
  (= Nat (+ m 0) (+ 0 m))))
(define base-plus-is-commutative
  plus-is-commutative-part1)

                 
(claim step-plus-is-commutative
       (Pi ([n-1 Nat])
           (-> (Pi ([m Nat])
                   (= Nat (+ m       n-1 ) (+       n-1  m)))
               (Pi ([m Nat])
                   (= Nat (+ m (add1 n-1)) (+ (add1 n-1) m))))))
(define step-plus-is-commutative
  (lambda (n-1)
    (lambda (casen-1) ;; casen-1 is a (Pi ([m]) (= Nat (+ m n-1) (+ n-1 m))) "any m commutes with n-1" (1)
       (lambda (m)
         (ind-Nat m
           (lambda (m) (= Nat (+ m (add1 n-1)) (+ (add1 n-1) m))) ;; the motive
           (symm (plus-is-commutative-part1 (add1 n-1))) ;; base case, of type (= Nat (+ 0 (add1 n-1))
                                                         ;;                           (+ (add1 n-1) 0))
                                                         ;; "0 commutes with (add1 n-1)"
           (lambda (m-1)
             (lambda (casem-1) ;; casem-1 is a (= Nat (+ m-1 (add1 n-1))
                          ;;                     (+ (add1 n-1) m-1))
                          ;; "m-1 commutes with (add1 n-1)" (2)
                          ;;
                          ;; we must return a (= Nat (+ (add1 m-1) (add1 n-1)) (+ (add1 n-1) (add1 m-1)))
                          ;;
                          ;; "(add1 m-1) commutes with (add1 n-1)"
                          ;;
                          ;; Now we push symbols around in the only way we can.
                          ;; Note how our evidence lines up out here ------------------|
               (trans (the (= Nat (+ (add1 m-1) (add1 n-1)) (add1 (+ m-1 (add1 n-1)))) (same (+ (add1 m-1) (add1 n-1)))) ;; step 1
                      (the (= Nat (add1 (+ m-1 (add1 n-1))) (+ (add1 n-1) (add1 m-1)))
               (trans (the (= Nat (add1 (+ m-1 (add1 n-1))) (add1 (+ (add1 n-1) m-1))) (cong casem-1 (+ 1))) ;; step 2
                      (the (= Nat (add1 (+ (add1 n-1) m-1)) (+ (add1 n-1) (add1 m-1)))
               (trans (the (= Nat (add1 (add1 (+ n-1 m-1))) (add1 (add1 (+ m-1 n-1)))) (symm (cong (casen-1 m-1) (+ 2)))) ;; step 3
                      (the (= Nat (add1 (add1 (+ m-1 n-1))) (+ (add1 n-1) (add1 m-1)))
               (trans (the (= Nat (add1 (add1 (+ m-1 n-1))) (add1 (+ (add1 m-1) n-1))) (same (add1 (add1 (+ m-1 n-1))))) ;; step 4
                      (the (= Nat (add1 (+ (add1 m-1) n-1)) (+ (add1 n-1) (add1 m-1)))
               (trans (the (= Nat (add1 (+ (add1 m-1) n-1)) (add1 (+ n-1 (add1 m-1)))) (cong (casen-1 (add1 m-1)) (+ 1))) ;; step 5
                      (the (= Nat (add1 (+ n-1 (add1 m-1))) (+ (add1 n-1) (add1 m-1))) (same (add1 (+ n-1 (add1 m-1)))) ;; step 6
                           )))))))))))))))))


(claim plus-is-commutative
 (Pi ([n Nat] [m Nat])
  (= Nat (+ m n) (+ n m))))
(define plus-is-commutative
 (lambda (n)
   (ind-Nat n
     mot-plus-is-commutative
     base-plus-is-commutative
     step-plus-is-commutative)))

(claim plus-has-an-additive-identity
  (Sigma ([zro Nat])
    (Pi ([n Nat])
      (= Nat (+ zro n) n))))
(define plus-has-an-additive-identity
  (cons zero
    (lambda (n) (same n))))

(claim mot-plus-is-associative
  (Pi ([b Nat] [c Nat] [a Nat])
    U))
(define mot-plus-is-associative
  (lambda (b c)
    (lambda (a) (= Nat (+ (+ a b) c) (+ a (+ b c))))))

(claim base-plus-is-associative
  (Pi ([b Nat] [c Nat])
    (= Nat (+ (+ zero b) c) (+ zero (+ b c)))))
(define base-plus-is-associative
  (lambda (b c)
    (same (+ b c))))

(claim step-plus-is-associative
  (Pi ([b Nat] [c Nat] [a Nat])
    (-> (= Nat (+ (+       a  b) c) (+       a  (+ b c)))
        (= Nat (+ (+ (add1 a) b) c) (+ (add1 a) (+ b c))))))
(define step-plus-is-associative
  (lambda (b c)
    (lambda (a)
      (lambda (casea)
        (cong casea (+ 1)))))) ;; honestly, I just guessed

(claim plus-is-associative
  (Pi ([a Nat] [b Nat] [c Nat])
    (= Nat (+ (+ a b) c) (+ a (+ b c)))))
(define plus-is-associative
  (lambda (a b)
    (lambda (c)
      (ind-Nat a ;; we induct on the first variable (becase the base is easy)
        (mot-plus-is-associative b c)
        (base-plus-is-associative b c)
        (step-plus-is-associative b c)))))
        
