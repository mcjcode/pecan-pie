@(include "nats.raw")  ;; get the definition of +

;; we'll need this lemma later define the
;; incr function.  see 08_add1_and_incr.raw
;; for details.
(claim incr
  (-> Nat Nat))
(define incr
  (lambda (n)
    (iter-Nat n
      1
      step-+)))

(claim mot-add1=incr
  (Pi ((n Nat))
    U))
(define mot-add1=incr
  (lambda (n)
    (= Nat (+ 1 n) (incr n))))

(claim base-add1=incr
  (= Nat (+ 1 zero) (incr zero)))
(define base-add1=incr
  (same (add1 zero)))

(claim step-add1=incr
  (Pi ((n Nat))
    (-> (= Nat (+ 1        n ) (incr       n) )
        (= Nat (+ 1  (add1 n)) (incr (add1 n))))))
(define step-add1=incr
  (lambda (_)
    (lambda (n-1case)
      (cong n-1case (the (-> Nat Nat) (lambda (n) (add1 n)))))))

;; (+ 1 n) = (+ n 1)
(claim add1=incr
 (Pi ((n Nat))
  (= Nat (+ 1 n) (incr n))))
;; and here is our proof:
(define add1=incr
   (lambda (n)
     (ind-Nat n
              mot-add1=incr
              base-add1=incr
              step-add1=incr)))


;; Now let's prove that + is commutative
;; i.e. that (+ n m) *equals* (+ m n)
;;
;; This will be an induction on n, but
;; at each n-step we will have to induct
;; on m.
(claim mot-plus-is-commutative-part1
 (Pi ([m Nat]) U))
(define mot-plus-is-commutative-part1  
 (lambda (m) (= Nat (+ m 0) (+ 0 m))))
  
(claim base-plus-is-commutative-part1
 (= Nat (+ 0 0) (+ 0 0)))
(define base-plus-is-commutative-part1
 (same 0))

(claim step-plus-is-commutative-part1
 (Pi ([m-1 Nat])
  (-> (= Nat (+       m-1  0) (+ 0       m-1))
      (= Nat (+ (add1 m-1) 0) (+ 0 (add1 m-1))))))
(define step-plus-is-commutative-part1
 (lambda (_) ;; (m-1), but we don't need it
  (lambda (casem-1)
   (cong casem-1 (the (-> Nat Nat) (lambda (k) (add1 k)))))))

(claim plus-is-commutative-part1
 (Pi ([m Nat]) ;; note that square brackets here work too.
  (= Nat (+ m 0) (+ 0 m))))
(define plus-is-commutative-part1
 (lambda (m)
  (ind-Nat m
           mot-plus-is-commutative-part1
           base-plus-is-commutative-part1
           step-plus-is-commutative-part1)))

(claim mot-plus-is-commutative
 (Pi ([n Nat])
     U))
(define mot-plus-is-commutative
  (lambda (n)
    (Pi ([m Nat])
      (= Nat (+ m n) (+ n m)))))

(claim base-plus-is-commutative
 (Pi ([m Nat])
  (= Nat (+ m 0) (+ 0 m))))
(define base-plus-is-commutative
  plus-is-commutative-part1)

                 
(claim step-plus-is-commutative
       (Pi ([n-1 Nat])
           (-> (Pi ([m Nat])
                   (= Nat (+ m       n-1 ) (+       n-1  m)))
               (Pi ([m Nat])
                   (= Nat (+ m (add1 n-1)) (+ (add1 n-1) m))))))
(define step-plus-is-commutative
  (lambda (n-1)
    (lambda (casen-1) ;; casen-1 is a (Pi ([m]) (= Nat (+ m n-1) (+ n-1 m))) "any m commutes with n-1" (1)
       (lambda (m)
         (ind-Nat m
           (lambda (m) (= Nat (+ m (add1 n-1)) (+ (add1 n-1) m))) ;; the motive
           (symm (plus-is-commutative-part1 (add1 n-1))) ;; base case, of type (= Nat (+ 0 (add1 n-1))
                                                         ;;                           (+ (add1 n-1) 0))
                                                         ;; "0 commutes with (add1 n-1)"
           (lambda (m-1)
             (lambda (casem-1) ;; casem-1 is a     (= Nat (+       m-1  (add1 n-1)) (+ (add1 n-1)       m-1))
                          ;;
                          ;; "m-1 commutes with (add1 n-1)" (2)
                          ;;
                          ;; we must return a (= Nat (+ (add1 m-1) (add1 n-1)) (+ (add1 n-1) (add1 m-1)))
                          ;;
                          ;; "(add1 m-1) commutes with (add1 n-1)"
                          ;;
                          ;; Now we push symbols around in the only way we can.
                          ;; Note how our evidence lines up out here ------------------|
                (trans (the (= Nat (+ (add1 m-1) (add1 n-1)) (add1 (+ m-1 (add1 n-1)))) (same (+ (add1 m-1) (add1 n-1))) ) 
                (trans (the (= Nat (add1 (+ m-1 (add1 n-1))) (add1 (+ (add1 n-1) m-1))) (cong casem-1 (+ 1))             ) 
                (trans (the (= Nat (add1 (+ (add1 n-1) m-1)) (add1 (add1 (+ n-1 m-1)))) (same (+ (add1 n-1) m-1))        )
                (trans (the (= Nat (add1 (add1 (+ n-1 m-1))) (add1 (add1 (+ m-1 n-1)))) (symm (cong (casen-1 m-1) (+ 2)))) 
                (trans (the (= Nat (add1 (add1 (+ m-1 n-1))) (add1 (+ (add1 m-1) n-1))) (same (add1 (add1 (+ m-1 n-1)))) ) 
                (trans (the (= Nat (add1 (+ (add1 m-1) n-1)) (add1 (+ n-1 (add1 m-1)))) (cong (casen-1 (add1 m-1)) (+ 1))) 
                       (the (= Nat (add1 (+ n-1 (add1 m-1))) (+ (add1 n-1) (add1 m-1))) (same (add1 (+ n-1 (add1 m-1)))  ) 
                           )))))))))))))


(claim plus-is-commutative
 (Pi ([n Nat] [m Nat])
  (= Nat (+ m n) (+ n m))))
(define plus-is-commutative
 (lambda (n)
   (ind-Nat n
     mot-plus-is-commutative
     base-plus-is-commutative
     step-plus-is-commutative)))

(claim plus-has-an-additive-identity
  (Sigma ([zro Nat])
    (Pi ([n Nat])
      (= Nat (+ zro n) n))))
(define plus-has-an-additive-identity
  (cons zero
    (lambda (n) (same n))))

(claim mot-plus-is-associative
  (Pi ([b Nat] [c Nat] [a Nat])
    U))
(define mot-plus-is-associative
  (lambda (b c)
    (lambda (a) (= Nat (+ (+ a b) c) (+ a (+ b c))))))

(claim base-plus-is-associative
  (Pi ([b Nat] [c Nat])
    (= Nat (+ (+ zero b) c) (+ zero (+ b c)))))
(define base-plus-is-associative
  (lambda (b c)
    (same (+ b c))))

(claim step-plus-is-associative
  (Pi ([b Nat] [c Nat] [a Nat])
    (-> (= Nat (+ (+       a  b) c) (+       a  (+ b c)))
        (= Nat (+ (+ (add1 a) b) c) (+ (add1 a) (+ b c))))))
(define step-plus-is-associative
  (lambda (b c)
    (lambda (a)
      (lambda (casea)
        (cong casea (+ 1)))))) ;; honestly, I just guessed

(claim plus-is-associative
  (Pi ([a Nat] [b Nat] [c Nat])
    (= Nat (+ (+ a b) c) (+ a (+ b c)))))
(define plus-is-associative
  (lambda (a b c)
      (ind-Nat a ;; we induct on the first variable (becase the base is easy)
        (mot-plus-is-associative b c)
        (base-plus-is-associative b c)
        (step-plus-is-associative b c))))

(claim mot-distributivity
  (Pi ([b Nat] [c Nat] [a Nat])
    U))
(define mot-distributivity
  (lambda (b c a)
    (= Nat (* (+ a b) c) (+ (* a c) (* b c)))))

(claim base-distributivity
  (Pi ([b Nat] [c Nat])
    (= Nat (* (+ zero b) c) (+ (* zero c) (* b c)))))
(define base-distributivity
  (lambda (b c)
    (same (* b c))))

(claim step-distributivity
  (Pi ([b Nat] [c Nat] [a Nat])
    (-> (= Nat (* (+       a  b) c) (+ (*       a  c) (* b c)))
        (= Nat (* (+ (add1 a) b) c) (+ (* (add1 a) c) (* b c))))))
        ;; ((1+a)+b)*c = ((a+1)+b)*c          commutativity of addition
        ;;             = (a+(1+b))*c          assoc of addition
        ;;             = a*c + (1+b)*c        inductive hypothesis
        ;;             = a*c + (c+(b*c))      def'n of multiplication
        ;;             = (a*c + c) + b*c      associativity of addition
        ;;             = (c + a*c) + b*c      commutativity of addition
        ;;             = ((1+a)*c) + b*c      definition 
(define step-distributivity
  (lambda (b c)
    (lambda (a)
      (lambda (casea)
        TODO))))

(claim distributivity
  (Pi ([a Nat] [b Nat] [c Nat])
    (= Nat (* (+ a b) c) (+ (* a c) (* b c))))) ;; (a+b)*c = (a*c)+(b*c)
(define distributivity
  (lambda (a b c)
    (ind-Nat a
      (mot-distributivity b c)
      (base-distributivity b c)
      TODO))) ;;(step-distributivity b c))))

(claim mult-has-an-identity
  (Sigma ([one Nat])
    (Pi ([n Nat])
      (= Nat (* one n) n))))
(define mult-has-an-identity
  (cons (add1 zero)
    (lambda (n)
      (same n))))

(claim mot-mult-is-associative
  (Pi ([b Nat] [c Nat] [a Nat])
    U))
(define mot-mult-is-associative
  (lambda (b c)
    (lambda (a) (= Nat (* (* a b) c) (* a (* b c))))))

(claim base-mult-is-associative
  (Pi ([b Nat] [c Nat])
    (= Nat (* (* zero b) c) (* zero (* b c)))))
(define base-mult-is-associative
  (lambda (b c)
    (same zero)))

(claim step-mult-is-associative
  (Pi ([b Nat] [c Nat] [a Nat])
    (-> (= Nat (* (*       a  b) c) (*       a  (* b c)))
        (= Nat (* (* (add1 a) b) c) (* (add1 a) (* b c))))))
(define step-mult-is-associative
  (lambda (b c)
    (lambda (a)
      (lambda (casea)
        TODO)))) ;; know (a*b)*c = a*(b*c)
                 ;; want to show ((a+1)*b)*c = (a+1)*(b*c)
                 ;;
                 ;;              ((a+1)*b)*c = (a*b+1*b)*c       'distributivity a 1 b'
                 ;;                          = (a*b)*c+(1*b)*c   'distributivity  (a*b) (1*b) c'
                 ;;                          = a*(b*c)+(1*b)*c   'commutativity of mult'
                 ;;                          = a*(b*c)+(b*c)     '1*b=b'
                 ;;                          = a*(b*c)+1*(b*c)   '(b*c)=1*(b*c)'
                 ;;                          = (a+1)*(b*c)       'distributivity a 1 (b*c)'

(claim mult-is-associative
  (Pi ([a Nat] [b Nat] [c Nat])
    (= Nat (* (* a b) c) (* a (* b c)))))
(define mult-is-associative
  (lambda (a b c)
      (ind-Nat a
        (mot-mult-is-associative b c)
        (base-mult-is-associative b c)
        (step-mult-is-associative b c))))

